/*
    Реализуйте метод, сливающий два отсортированных по неубыванию массива чисел в один
    отсортированный в том же порядке массив.
    Массивы могут быть любой длины, в том числе нулевой.
    Срезы НЕ применяю: много лишних действий, замедляющих решение
    Алгоритм решения изложен здесь:
    https://habr.com/ru/post/281675/
*/
package Tsuker;

import java.util.Arrays;                        // Импорт модуля Arrays
//import java.util.Scanner;                     // Импорт модуля ввода Scanner

public class Main {

    public static void main(String[] args) {
        int[] ar1 = new int[]{-1, 7, 7, 17, 19};    // Первый массив {-1, 7, 7, 17, 19}
        int len1 = ar1.length;                      // Длина первого массива
        int[] result;                               // Массив для слияния введенных отсортированных
        System.out.println(len1);                   // Печать длины первого массива
        System.out.println(Arrays.toString(ar1));   // Печать первого массива

        int[] ar2 = new int[]{11, 15, 17, 17, 19};  // Второй массив {11, 15, 17, 17, 19}
        int len2 = ar2.length;                      // Длина второго массива
        System.out.println(len2);                   // Печать длины второго массива
        System.out.println(Arrays.toString(ar2));   // Печать второго массива

        result = mergeArrays(ar1, ar2);                 // Получение результирующего массива
        System.out.println(Arrays.toString(result));    // Печать результирующего массива
    }

    public static int[] mergeArrays(int[] a1, int[] a2) {
        int way = 3;                            // Переменная для ветвления в switch (way)
        int len1 = a1.length;                   // длина первого массива
        if (len1 == 0) {way = 2;}               // Второй путь switch
        int len2 = a2.length;                   // длина второго массива
        if (len2 == 0) {way = 1;}               // Первый путь switch
        if (len1 == 0 && len2 == 0) {way = 0;}  // Путь 0 для switch
        if (len1 != 0 && len2 !=0 ) {way = 3;}  // Путь 3 для switch
        int lensum;                             // Длина суммарного массива

        lensum = len1 + len2;               // Длина смерженного массива sum
        int[] sum = new int[lensum];        // Массив для слияния отсортированных массивов
        int i = 0, j = 0, k = 0;            // Индексы 1-го, 2-го и суммарного масссивов (начальные значения)
        int mem;                            // Переменная для выборки элементов (с индексом 0)

        switch (way) {                      // Переключатель ветвления
            case 0:                         // Если оба массива имеют длину 0
                return a1;                  // Возврат массива нулевой длины

            case 1:                         // Если длина второго массива == 0
                return a1;                  // Возврат первого массива

            case 2:                         // Если длина первого массива == 0
                return a2;                  // Возврат второго массива

            case 3:                         // Если длины обоих массивов не равны 0
                for (k = 0; k < lensum; k++) {      // Цикл по элементам суммирующего массива

                    if (i > len1 - 1 ) {            // Если индекс 1-го массива больше длины массива
                        mem = a2[j];                // Выбираем элемент из 2-го массива
                        sum[k] = mem;               // Засылаем в суммарный массив
                        j++;                        // Увеличиваем счетчик 2-го массива
                        }
                    else if (j > len2 -1 ) {        // Если индекс 2-го массива больше длины массива
                        mem = a1[i];                // Выбираем элемент из 1-го массива
                        sum[k] = mem;               // Засылаем в суммарный массив
                        i++;                        // Увеличиваем счетчик 1-го массива
                        }
                    else if (a1[i] < a2[j]) {       // Если a1[i] < a2[j]
                        mem = a1[i];                // Выбираем элемент из 1-го массива
                        sum[k] = mem;               // Засылаем в суммарный массив
                        i++;                        // Увеличиваем счетчик 1-го массива
                        }
                    else {                          // Иначе (a1[i] <= a2[j])
                        mem = a2[j];                // Выбираем элемент из 2-го массива
                        sum[k] = mem;               // Засылаем в суммарный массив
                        j++;                        // Увеличиваем счетчик 2-го массива
                        }
                }                                   // Конец цикла по суммарному массиву
        }                                           // Завершение ветвления switch
        return sum;                                 // Возврат смерженного массива
    }
}

